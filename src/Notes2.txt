public class EfaDirektFrame extends JFrame implements ActionListener {
  EfaDirektBackgroundTask efaDirektBackgroundTask = null;

  //Construct the frame
  public EfaDirektFrame() {
    appIni();
  }

  void appIni() {
    // Nachrichten an Admin einlesen
    Daten.nachrichten = new NachrichtenAnAdmin(Daten.efaDataDirectory+Daten.DIREKTNACHRICHTEN);
    if (!EfaUtil.canOpenFile(Daten.nachrichten.getFileName())) {
      if (!Daten.nachrichten.writeFile()) {
          haltProgram(LogString.logstring_fileCreationFailed(Daten.nachrichten.getFileName(),
                  International.getString("Nachrichtendatei")), Daten.HALT_FILEOPEN);
      }
    } else {
      if (!Daten.nachrichten.readFile()) {
          haltProgram(LogString.logstring_fileOpenFailed(Daten.nachrichten.getFileName(),
                  International.getString("Nachrichtendatei")), Daten.HALT_FILEOPEN);
      }
    }
    Logger.setNachrichtenAnAdmin(Daten.nachrichten);
    updateUnreadMessages();

    // Admin-Paßwort vorhanden?
    boolean neuerSuperAdmin = false;
    if (Daten.efaConfig.admins.get(Admin.SUPERADMIN) == null) {
      Logger.log(Logger.INFO, Logger.MSG_ERR_NOSUPERADMIN,
              International.getString("Kein Super-Admin gefunden."));
      try {
        // gibt es noch das Sicherheitsfile?
        if (!Daten.efaSec.secFileExists()) {
          String s = International.getString("efa konnte kein Super-Admin Paßwort finden!") + " " +
                     International.getMessage("Aus Gründen der Sicherheit verweigert efa den Dienst. "+
                     "Bitte installiere efa neu oder kontaktiere den Entwickler: {email}",Daten.EMAILHELP);
          haltProgram(s, Daten.HALT_EFASECADMIN);
        }
      } catch(Exception e) {
        String s = International.getMessage("efa konnte kein Super-Admin Paßwort finden, und bei den folgenden Tests trat ein Fehler auf: {error}",e.toString()) + " " +
                   International.getMessage("Aus Gründen der Sicherheit verweigert efa den Dienst. "+
                   "Bitte installiere efa neu oder kontaktiere den Entwickler: {email}",Daten.EMAILHELP);
        haltProgram(s, Daten.HALT_EFASECADMIN);
      }
      String pwd = "";
      Dialog.infoDialog(International.getString("Willkommen bei efa Bootshaus"),
                        International.getString("Mitglieder dürfen in efa nur Fahrten eintragen. Alle weiteren "+
                        "Aktionen dürfen nur von einem Administrator ausgeführt werden. "+
                        "Der Super-Administrator (Haupt-Administrator) hat uneingeschränkte "+
                        "Rechte, die anderen Administratoren können eingeschränkte Rechte "+
                        "besitzen.\n"+
                        "Der Name des Super-Administrators lautet 'admin'. Zur Zeit gibt es "+
                        "noch kein Paßwort für 'admin'. Du wirst nun gleich aufgefordert, ein "+
                        "neues Paßwort für den Super-Administrator 'admin' einzugeben."));

      pwd = NewPasswordFrame.getNewPassword(this,Admin.SUPERADMIN);
      if (pwd == null) {
        haltProgram(International.getString("Paßworteingabe für Super-Admin abgebrochen."), Daten.HALT_EFASECADMIN);
      }

      Admin root = new Admin(Admin.SUPERADMIN,EfaUtil.getSHA(pwd));
      Daten.efaConfig.admins.put(Admin.SUPERADMIN,root);
      if (!Daten.efaConfig.writeFile()) {
          haltProgram(LogString.logstring_fileWritingFailed(Daten.efaConfig.getFileName(), International.getString("Konfigurationsdatei")),
                  Daten.HALT_EFASECADMIN);
      }
      Logger.log(Logger.INFO, Logger.MSG_EVT_SUPERADMINCREATED,
              International.getString("Neuer Super-Admin erstellt."));
      neuerSuperAdmin = true;
    }


    if (Daten.efaSec.secFileExists() &&
            Daten.efaSec.isSecFileWritable() && // if we cannot write efaSec, this Security Check is currently not possible
            !Daten.efaSec.isDontDeleteSet()) {
      switch (Dialog.auswahlDialog(International.getString("Sicherheits-Frage"),
              International.getString("Aus Gründen der Sicherheit sollte es im Bootshaus nicht möglich sein, "+
                                   "das herkömmliche efa ohne Paßwort zu starten, da dort jeder Benutzer auch ohne "+
                                   "Admin-Rechte alle Daten manipulieren kann. Es wird daher dringend "+
                                   "geraten, das herkömmliche efa ebenfalls durch das Admin-Paßwort zu sichern! "+
                                   "Für den Einsatz zu Hause ist es natürlich nicht erforderlich, efa "+
                                   "zu sperren, da hier i.d.R. keine Mißbrauchgefahr besteht.\n\n"+
                                   "Möchtest Du, daß die herkömmliche efa-Oberfläche paßwortgeschützt wird und nur "+
                                   "noch für Admins zugänglich ist (für Bootshaus-Einsatz dringend empfohlen!)?\n"+
                                   "Herkömmliche efa-Oberfläche ..."),
                                   "... " + International.getString("durch Paßwort schützen"),
                                   "... " + International.getString("nicht schützen"))) {
        case 0: // Sperren
          if (Daten.efaSec.delete(true)) {
              String s = International.getString("Der Start des herkömmlichen efa ist nun nur noch mit Paßwort möglich!");
              Logger.log(Logger.INFO, Logger.MSG_EVT_EFASECURE, s);
              Dialog.meldung(s);
          } else {
              haltProgram(International.getMessage("efa konnte die Datei {filename} nicht löschen und wird daher beendet!",
                      Daten.efaSec.getFilename()), Daten.HALT_EFASEC);
          }
          break;
        case 1:
          if (Daten.efaSec.writeSecFile(Daten.efaSec.getSecValue(),true)) {
              String s = International.getString("Der Start des herkömmlichen efa ist auch ohne Paßwort möglich!");
              Logger.log(Logger.WARNING, Logger.MSG_WARN_EFAUNSECURE, s);
              Dialog.meldung(s);
          } else {
              haltProgram(International.getMessage("efa konnte die Datei {filename} nicht schreiben und wird daher beendet!",
                      Daten.efaSec.getFilename()), Daten.HALT_EFASEC);
          }
          break;
        default:
          haltProgram(null, Daten.HALT_EFASEC);
      }
    }

    // efaSec löschen (außer, wenn DontDelete-Flag gesetzt ist)
    if (Daten.efaSec.secFileExists() &&
            Daten.efaSec.isSecFileWritable() && // if we cannot write efaSec, this Security Check is currently not possible
            !Daten.efaSec.delete(false)) {
      String s = International.getMessage("efa konnte die Datei {filename} nicht löschen und wird daher beendet!",Daten.efaSec.getFilename());
      haltProgram(s, Daten.HALT_EFASEC);
    }

    // Fahrtenbuch öffnen, falls keines angegeben
    if (Daten.efaConfig.direkt_letzteDatei.getValue().length() == 0) {

      if (neuerSuperAdmin) Dialog.infoDialog(International.getString("Fahrtenbuch auswählen"),
                                             International.getString("Bisher wurde noch kein Fahrtenbuch ausgewählt, mit dem "+
                                             "gearbeitet werden soll. Im folgenden Schritt wirst Du "+
                                             "aufgefordert, ein Fahrtenbuch auszuwählen. "+
                                             "Du mußt Dich daher zunächst als Administrator anmelden: "+
                                             "Der Name des Super-Administrators lautet 'admin', das "+
                                             "Paßwort hast Du eben selbst gewählt."));
      Admin admin = null;
      do {
        admin = AdminLoginFrame.login(this,International.getString("Kein Fahrtenbuch ausgewählt"));
        if (admin == null) {
            haltProgram(International.getString("Programmende, da kein Fahrtenbuch ausgewählt und Admin-Login nicht erfolgreich."), Daten.HALT_FILEOPEN);
        }
        if (!admin.allowedFahrtenbuchAuswaehlen) {
            Dialog.error(International.getMessage("Du hast als Admin {name} keine Berechtigung, ein Fahrtenbuch auszuwählen!",admin.name));
        }
      } while (!admin.allowedFahrtenbuchAuswaehlen);
      String dat = null;
      switch (Dialog.auswahlDialog(International.getString("Fahrtenbuch auswählen"),
              International.getString("Möchtest Du ein neues Fahrtenbuch erstellen oder ein vorhandenes öffnen?"),
              International.getString("Neues Fahrtenbuch erstellen"),
              International.getString("Vorhandenes Fahrtenbuch öffnen"))) {
        case 0: // Neues Fahrtenbuch erstellen
          FahrtenbuchNeuFortsetzenFrame dlg = new FahrtenbuchNeuFortsetzenFrame(this,false);
          Dialog.setDlgLocation(dlg,this);
          dlg.setModal(!Dialog.tourRunning);
          dlg.show();
          if (Daten.fahrtenbuch != null) {
            dat = Daten.fahrtenbuch.getFileName();
          }
          break;
        case 1: // Vorhandenes Fahrtenbuch öffnen
          dat = Dialog.dateiDialog(this,International.getString("Fahrtenbuch öffnen"),
                  International.getString("efa Fahrtenbuch")+" (*.efb)","efb",Daten.efaDataDirectory,false);
          break;
        default:
          haltProgram(International.getString("Kein Fahrtenbuch ausgewählt"), Daten.HALT_FILEOPEN);
      }
      if (dat == null || dat.length()==0) {
          haltProgram(International.getString("Kein Fahrtenbuch ausgewählt"), Daten.HALT_FILEOPEN);
      }
      Daten.efaConfig.direkt_letzteDatei.setValue(dat);
      Logger.log(Logger.INFO, Logger.MSG_EVT_NEWLOGBOOKOPENED,
              International.getMessage("Neue Fahrtenbuchdatei '{filename}' ausgewählt.",dat));
      if (!Daten.efaConfig.writeFile()) {
          haltProgram(LogString.logstring_fileCreationFailed(Daten.efaConfig.getFileName(),
                  International.getString("Konfigurationsdatei")), Daten.HALT_FILEOPEN);
      }
    }

    // EfaFrame vorbereiten
    efaFrame = new EfaFrame(this,Daten.nachrichten);
    Dimension dlgSize = efaFrame.getSize();
    efaFrame.setFixedLocation((Dialog.screenSize.width - dlgSize.width) / 2, (Dialog.screenSize.height - dlgSize.height) / 2);

    // ReservierungsChecker-Thread starten
    alive();
    efaDirektBackgroundTask = new EfaDirektBackgroundTask(this);
    efaDirektBackgroundTask.start();
  }


  public boolean sindNochBooteUnterwegs() {
    return bootStatus.getBoote(BootStatus.STAT_UNTERWEGS).size()>0;
  }




  void eintragAendern(String boot) {
    DatenFelder d = (DatenFelder)bootStatus.getExactComplete(boot);
    if (d == null) {
      if (boot.startsWith("----------")) return; // kein Fehler, wenn jemand es geschafft hat, die Trennlinie zu markieren!
      String s = International.getString("Programmfehler") + ": " +
              International.getMessage("Boot {boat} nicht in der Statusliste gefunden!",boot);
      Dialog.error(s);
      Logger.log(Logger.ERROR,Logger.MSG_ERR_BOATNOTFOUNDINSTATUS,s);
      return;
    }

    if (d.get(BootStatus.LFDNR).trim().length()==0) {
      // keine LfdNr eingetragen: Das kann passieren, wenn der Admin den Status der Bootes manuell geändert hat!
      String s = International.getMessage("Es gibt keine offene Fahrt im Fahrtenbuch mit dem Boot {boat}.",boot);
      Dialog.error(s + " " + International.getString("Der Eintrag kann nicht geändert werden."));
      Logger.log(Logger.ERROR,Logger.MSG_ERR_NOLOGENTRYFORBOAT,
              s + " " + International.getString("Bitte korrigiere den Status des Bootes im Admin-Modus."));
      return;
    }
    setEnabled(false);
    efaFrame.direktFahrtAnfangKorrektur(boot,d.get(BootStatus.LFDNR));
  }


  void booteAufFahrt_keyReleased(KeyEvent e) {
    clearAllPopups();
    if (e != null) {
      if (e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_SPACE) {
        doppelklick(2,booteAufFahrt);
        return;
      }
      scrollToEntry(booteAufFahrt,booteAufFahrtListData,String.valueOf(e.getKeyChar()),10);
    }
    showBootStatus(2,booteAufFahrt,(e != null && e.getKeyCode() == 38 ? -1 : 1)); // KeyCode 38 == Cursor Up
  }
  void booteNichtVerfuegbar_keyReleased(KeyEvent e) {
    clearAllPopups();
    if (e != null) {
      if (e.getKeyCode() == KeyEvent.VK_ENTER || e.getKeyCode() == KeyEvent.VK_SPACE) {
        doppelklick(3,booteNichtVerfuegbar);
        return;
      }
      scrollToEntry(booteNichtVerfuegbar,booteNichtVerfuegbarListData,String.valueOf(e.getKeyChar()),5);
    }
    showBootStatus(3,booteNichtVerfuegbar,(e != null && e.getKeyCode() == 38 ? -1 : 1)); // KeyCode 38 == Cursor Up
  }


  private static String removeDoppeleintragFromBootsname(String boot) {
    if (boot == null || boot.length()==0) return boot;
    if (boot.charAt(boot.length()-1) != ']') return boot;
    int anf = boot.indexOf(" [");
    if (anf<0) return boot;
    return boot.substring(0,anf);
  }


  // mode bestimmt die Art der Checks
  // mode==1 - alle Checks durchführen
  // mode==2 - nur solche Checks durchführen, bei denen es egal ist, ob das Boot aus der Liste direkt ausgewählt wurde
  //           oder manuell über <anders Boot> eingegeben wurde. Der Aufruf von checkFahrtbeginnFuerBoot mit mode==2
  //           erfolgt aus EfaFrame.java.
  public boolean checkFahrtbeginnFuerBoot(String boot, int mode) {
    if (boot == null) return true;
    DatenFelder d = bootStatus.getExactComplete(boot);
    String bootsname = removeDoppeleintragFromBootsname(boot);
    if (d == null) {
      if (boot.startsWith("----------")) return false; // kein Fehler, wenn jemand es geschafft hat, die Trennlinie zu markieren!
      if (mode == 2) return true; // anderes Boot
      String s = International.getString("Programmfehler") + ": " +
              International.getMessage("Boot {boat} nicht in der Statusliste gefunden!",boot);
      Dialog.error(s);
      Logger.log(Logger.ERROR,Logger.MSG_ERR_BOATNOTFOUNDINSTATUS,s);
      return false;
    }
    int status = BootStatus.getStatusID(d.get(BootStatus.STATUS));

    if (status == BootStatus.STAT_UNTERWEGS) {
      if (mode == 1) {
        switch (Dialog.auswahlDialog(International.getString("Boot bereits unterwegs"),
                                     International.getMessage("Das Boot {boat} ist laut Liste bereits unterwegs.",bootsname) + "\n" +
                                     (d != null ? International.getString("Bemerkung")+": " + d.get(BootStatus.BEMERKUNG) + "\n" : "") +
                                     "\n" +
                                     International.getString("Was möchtest Du tun?"),
                                     International.getString("Neue Fahrt beginnen"),
                                     International.getString("Vorhandenen Eintrag ändern"),
                                     International.getString("Nichts"))) {
          case 0:
            break;
          case 1:
            eintragAendern(boot);
            return false;
          case 2:
            return false;
          default:
            return false;
        }
      } else {
        if (Dialog.yesNoCancelDialog(International.getString("Boot bereits unterwegs"),
                                     International.getMessage("Das Boot {boat} ist laut Liste bereits unterwegs.",bootsname) + "\n" +
                                     (d != null ? International.getString("Bemerkung")+": " + d.get(BootStatus.BEMERKUNG) + "\n" : "") +
                                     "\n" +
                                     International.getString("Möchtest Du trotzdem das Boot benutzen?"))
                      != Dialog.YES) return false;
      }
    }
    if (status == BootStatus.STAT_NICHT_VERFUEGBAR && !d.get(BootStatus.LFDNR).equals(BootStatus.RES_LFDNR)) {
      if (Dialog.yesNoCancelDialog(International.getString("Boot gesperrt"),
                                     International.getMessage("Das Boot {boat} ist laut Liste nicht verfügbar.",bootsname) + "\n" +
                                     (d != null ? International.getString("Bemerkung")+": " + d.get(BootStatus.BEMERKUNG) + "\n" : "") +
                                     "\n" +
                                             International.getString("Möchtest Du trotzdem das Boot benutzen?"))
                    != Dialog.YES) return false;
    }


    DatenFelder d2 = bootStatus.getExactComplete(removeDoppeleintragFromBootsname(boot));
    BoatReservation res = BootStatus.getReservierung(d,System.currentTimeMillis(),Daten.efaConfig.efaDirekt_resLookAheadTime.getValue());
    if (res == null && d2 != null) res = BootStatus.getReservierung(d2,System.currentTimeMillis(),Daten.efaConfig.efaDirekt_resLookAheadTime.getValue());
    if (res != null) {
      if (Dialog.yesNoCancelDialog(International.getString("Boot reserviert"),
              International.getMessage("Das Boot {boat} ist {currently_or_in_x_minutes} für {name} reserviert.",
                                       bootsname,
                                       (res.validInMinutes == 0 ?
                                           International.getString("zur Zeit") :
                                           International.getMessage("in {x} Minuten",(int)res.validInMinutes)),
                                           res.getForName())+"\n"+
              (res.getReason().length()>0 ? " ("+International.getString("Grund")+": "+res.getReason()+")\n" : "") +
              International.getMessage("Die Reservierung liegt {from_time_to_time} vor.",BootStatus.makeReservierungText(res))+"\n"+
              International.getString("Möchtest Du trotzdem das Boot benutzen?"))
                    != Dialog.YES) return false;
    }
    if (d.get(BootStatus.BOOTSSCHAEDEN).trim().length() > 0 || (d2 != null && d2.get(BootStatus.BOOTSSCHAEDEN).trim().length() > 0)) {
      if (Dialog.yesNoDialog(International.getString("Bootsschaden gemeldet"),
              International.getMessage("Für das Boot {boat} wurde folgender Bootsschaden gemeldet:",bootsname)+"\n"+
              "\""+
              (d.get(BootStatus.BOOTSSCHAEDEN).trim().length() > 0 ? d.get(BootStatus.BOOTSSCHAEDEN).trim() : d2.get(BootStatus.BOOTSSCHAEDEN).trim())
              +"\"\n\n"+
              International.getString("Möchtest Du trotzdem das Boot benutzen?"))
                             != Dialog.YES) return false;
    }
    return true;
  }

  private String createStatusString(String fahrttype, String ziel, String datum, String zeit, String person) {
    String aufFahrtart = "";
    if (Daten.efaTypes != null && fahrttype != null) {
      if (fahrttype.equals(EfaTypes.TYPE_SESSION_REGATTA)) {
          aufFahrtart = " " +
          International.getMessage("auf {trip_type}",Daten.efaTypes.getValue(EfaTypes.CATEGORY_SESSION, EfaTypes.TYPE_SESSION_REGATTA));
      }
      if (fahrttype.equals(EfaTypes.TYPE_SESSION_JUMREGATTA)) {
          aufFahrtart = " " +
          International.getMessage("auf {trip_type}",Daten.efaTypes.getValue(EfaTypes.CATEGORY_SESSION, EfaTypes.TYPE_SESSION_JUMREGATTA));
      }
      if (fahrttype.equals(EfaTypes.TYPE_SESSION_TRAININGCAMP)) {
          aufFahrtart = " " +
          International.getMessage("auf {trip_type}",Daten.efaTypes.getValue(EfaTypes.CATEGORY_SESSION, EfaTypes.TYPE_SESSION_TRAININGCAMP));
      }
      if (fahrttype.startsWith(EfaTypes.TYPE_SESSION_MULTIDAY)) {
          aufFahrtart = " " +
          International.getMessage("auf {trip_type}",Daten.efaTypes.getValue(EfaTypes.CATEGORY_SESSION, EfaTypes.TYPE_SESSION_MULTIDAY));
      }
    }
    String nachZiel = "";
    if (aufFahrtart.length() == 0 && ziel.length() > 0) {
      nachZiel = " " + International.getMessage("nach {destination}",ziel);
    }
    return  International.getString("unterwegs")+aufFahrtart+nachZiel+
            " " + International.getMessage("seit {date}",datum) +
            (zeit.trim().length()>0 ? " " + International.getMessage("um {time}",zeit) : "") +
            " "+International.getMessage("mit {crew}",person);
  }

  private boolean isMultiDayFahrtart(String fahrttype) {
      if (fahrttype.equals(EfaTypes.TYPE_SESSION_REGATTA)) return true;
      if (fahrttype.equals(EfaTypes.TYPE_SESSION_JUMREGATTA)) return true;
      if (fahrttype.equals(EfaTypes.TYPE_SESSION_TRAININGCAMP)) return true;
      if (fahrttype.startsWith(EfaTypes.TYPE_SESSION_MULTIDAY)) return true;
      return false;
  }

  public void fahrtBegonnen(String boot, String lfdNr, String datum, String zeit, String person, String fahrttype, String ziel) {
    int status = BootStatus.STAT_VERFUEGBAR;
    DatenFelder d = bootStatus.getExactComplete(boot);
    if (d == null) {
      Logger.log(Logger.INFO, Logger.MSG_EVT_TRIPUNKNOWNBOAT,
              International.getString("Fahrtbeginn eines unbekannten Bootes")+": "+boot);
      d = new DatenFelder(BootStatus._FELDANZ);
      d.set(BootStatus.NAME,boot);
      d.set(BootStatus.UNBEKANNTESBOOT,"+");
    } else {
      status = BootStatus.getStatusID(d.get(BootStatus.STATUS));
    }

    if (status != BootStatus.STAT_VERFUEGBAR && !d.get(BootStatus.LFDNR).equals(BootStatus.RES_LFDNR)) {
      String tmp = null;

      // Bootsnamen um Timestamp erweitern, der bislang noch nicht verwendet wurde
      for (char c = 'A'-1; c<='Z' && tmp == null; c++) {
        tmp = boot + " ["+EfaUtil.getCurrentTimeStampDD_MM_HH_MM() + (c<'A' ? "" : ""+c) + "]";
        if (bootStatus.getExact(tmp) != null) tmp = null;
      }

      if (tmp == null) { // alle 27 Timestamps für dieses Boot schon vergeben: sollte niemals passieren ...
        Logger.log(Logger.ERROR, Logger.MSG_ERR_TRIPSTARTNOTPOSSIBLE1,
                International.getMessage("Fahrtbeginn des Bootes {boat} nicht möglich!",boot));
        return;
      }

      boot = tmp;
      Logger.log(Logger.INFO, Logger.MSG_EVT_TRIPSTART_BNA,
              International.getMessage("Fahrtbeginn eines Bootes, welches laut Liste nicht verfügbar ist (Status [{status}]: {notes}).",
                                       status,d.get(BootStatus.BEMERKUNG)) +
              International.getMessage("Neuer Eintrag als Boot: {boat}",boot));
      DatenFelder old_d = d;
      d = new DatenFelder(BootStatus._FELDANZ);
      d.set(BootStatus.NAME,boot);
      d.set(BootStatus.UNBEKANNTESBOOT,"+"); // Doppeleinträge sind immer "unbekannte" Boote!!
      // Bugfix: auch Bootsschäden und Reservierungen müssen übernommen werden, da sonst diese Daten u.U. verloren gehen
      // könnten, wenn der andere Eintrag als erstes und dieser als zweites beendet wird.
      d.set(BootStatus.BOOTSSCHAEDEN,old_d.get(BootStatus.BOOTSSCHAEDEN));
      d.set(BootStatus.RESERVIERUNGEN,old_d.get(BootStatus.RESERVIERUNGEN));
    }

    bootStatus.delete(boot);
    d.set(BootStatus.LFDNR,lfdNr);
    if (Daten.efaConfig.efaDirekt_wafaRegattaBooteAufFahrtNichtVerfuegbar.getValue() && isMultiDayFahrtart(fahrttype)) {
        d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_NICHT_VERFUEGBAR));
    } else {
        d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_UNTERWEGS));
    }
    d.set(BootStatus.BEMERKUNG,createStatusString(fahrttype,ziel,datum,zeit,person));
    bootStatus.add(d);
    setKombiBootStatus(boot,"",BootStatus.STAT_VORUEBERGEHEND_VERSTECKEN,
            International.getString("vorübergehend von efa versteckt"));
    if (!bootStatus.writeFile()) {
        LogString.logError_fileWritingFailed(bootStatus.getFileName(), International.getString("Bootsstatus-Liste"));
    }
    updateBootsListen();
  }

  public void fahrtBeginnKorrigiert(String boot, String lfdNr, String datum, String zeit, String person, String fahrttype, String ziel, String ursprBoot) {
    if (!boot.equals(ursprBoot)) {
      // Bootsname wurde geändert
      Logger.log(Logger.INFO, Logger.MSG_EVT_TRIPSTART_CORR,
              International.getString("Fahrtbeginn korrigiert")+": #"+lfdNr+" - "+
              International.getMessage("Änderung des Bootsnamens von {original_name} in {new_name}.",ursprBoot,boot));
      fahrtBeendet(ursprBoot,true);
      fahrtBegonnen(boot,lfdNr,datum,zeit,person,fahrttype,ziel);
      return;
    }

    // Bootsname wurde nicht geändert
    int status = BootStatus.STAT_VERFUEGBAR;
    DatenFelder d = bootStatus.getExactComplete(boot);
    if (d == null) {
      Logger.log(Logger.INFO, Logger.MSG_EVT_TRIPSTART_CORRUKNW,
              International.getString("Fahrtbeginn korrigiert")+": "+
              International.getString("Korrektur des Fahrtbeginns eines unbekannten Bootes")+": "+boot);
      return;
    }
    status = BootStatus.getStatusID(d.get(BootStatus.STATUS));
    if (status != BootStatus.STAT_UNTERWEGS) {
      Logger.log(Logger.INFO, Logger.MSG_EVT_TRIPSTART_CORRSNOT,
              International.getString("Fahrtbeginn korrigiert")+": "+
              International.getMessage("Korrektur des Fahrtbeginns des Bootes {boat}, das nicht unterwegs ist [Status: {status}]",boot,status));
      return;
    }
    bootStatus.delete(boot);
    d.set(BootStatus.LFDNR,lfdNr);
    if (Daten.efaConfig.efaDirekt_wafaRegattaBooteAufFahrtNichtVerfuegbar.getValue() && isMultiDayFahrtart(fahrttype)) {
        d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_NICHT_VERFUEGBAR));
    } else {
        d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_UNTERWEGS));
    }
    d.set(BootStatus.BEMERKUNG,createStatusString(fahrttype,ziel,datum,zeit,person));
    bootStatus.add(d);
    setKombiBootStatus(boot,"",BootStatus.STAT_VORUEBERGEHEND_VERSTECKEN,
            International.getString("vorübergehend von efa versteckt"));
    if (!bootStatus.writeFile()) {
        LogString.logError_fileWritingFailed(bootStatus.getFileName(), International.getString("Bootsstatus-Liste"));
    }
    updateBootsListen();
  }


  public void fahrtBeendet(String boot, boolean interaktiv) {
    DatenFelder d = (DatenFelder)bootStatus.getExactComplete(boot);
    if (d == null) {
      if (boot.startsWith("----------")) return; // kein Fehler, wenn jemand es geschafft hat, die Trennlinie zu markieren!
      String s = International.getString("Programmfehler") + ": " +
              International.getMessage("Boot {boat} nicht in der Statusliste gefunden!",boot);
      if (interaktiv) {
          Dialog.error(s);
      }
      Logger.log(Logger.ERROR,Logger.MSG_ERR_BOATNOTFOUNDINSTATUS,s);
      return;
    }

    // Boot aus Statustliste löschen
    bootStatus.delete(boot);

    if (!d.get(BootStatus.UNBEKANNTESBOOT).equals("+")) {
      // es handelt sich um *kein* unbekanntes Boot, also auch nicht um einen Doppelaustrag

      // gibt es einen zu diesem Bootsnamen passenden Doppelaustrag?
      DatenFelder dd = bootStatus.getCompleteFirst(boot+" [");
      if (dd != null) {
        // Ja, Doppeleintrag existiert: Dann eckige Klammern dort löschen und Boot *nicht* als verfügbar markieren
        bootStatus.delete(dd.get(BootStatus.NAME));
        dd.set(BootStatus.NAME,boot);
        dd.set(BootStatus.UNBEKANNTESBOOT,"-");
        bootStatus.add(dd);
      } else {
        // Nein, Doppeleintrag existiert nicht: Boot als verfügbar markieren
        d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_VERFUEGBAR));
        d.set(BootStatus.BEMERKUNG,BootStatus.getStatusName(BootStatus.STAT_VERFUEGBAR));
        d.set(BootStatus.LFDNR,"");
        bootStatus.add(d);
        setKombiBootStatus(boot,"",BootStatus.STAT_VERFUEGBAR,BootStatus.getStatusName(BootStatus.STAT_VERFUEGBAR));
      }
    }

    if (!bootStatus.writeFile()) {
        LogString.logError_fileWritingFailed(bootStatus.getFileName(), International.getString("Bootsstatus-Liste"));
    }
    if (interaktiv) {
      updateBootsListen();
      efaDirektBackgroundTask.interrupt();
    }
  }


  void fahrtAbbruch(String boot, boolean interaktiv) {
    DatenFelder d = bootStatus.getExactComplete(boot);
    if (d == null) {
      if (boot.startsWith("----------")) return; // kein Fehler, wenn jemand es geschafft hat, die Trennlinie zu markieren!
      String s = International.getString("Programmfehler") + ": " +
              International.getMessage("Boot {boat} nicht in der Statusliste gefunden!",boot);
      if (interaktiv) {
          Dialog.error(s);
      }
      Logger.log(Logger.ERROR,Logger.MSG_ERR_BOATNOTFOUNDINSTATUS,s);
      return;
    }
    if (interaktiv && Dialog.yesNoDialog(International.getString("Fahrt abbrechen"),
                                         International.getMessage("Die Fahrt des Bootes {boat} sollte nur abgebrochen werden, "+
                                           "wenn sie nie stattgefunden hat. In diesem Fall wird der begonnene Eintrag wieder entfernt.",
                                           removeDoppeleintragFromBootsname(boot))+
                                           "\n"+
                                           International.getString("Möchtest Du die Fahrt wirklich abbrechen?")) != Dialog.YES) return;
    if (d.get(BootStatus.LFDNR).trim().length() == 0) {
        String s = International.getMessage("Es gibt keine offene Fahrt im Fahrtenbuch mit dem Boot {boat}.",d.get(BootStatus.NAME))
                 + " " + International.getString("Die Fahrt kann nicht abgebrochen werden.");
        Logger.log(Logger.ERROR,Logger.MSG_ERR_NOLOGENTRYFORBOAT,
              s + " " + International.getString("Bitte korrigiere den Status des Bootes im Admin-Modus."));
        if (interaktiv) Dialog.error(s);
        return;
    }
    if (Daten.fahrtenbuch.getExact(d.get(BootStatus.LFDNR)) == null) {
        String s = International.getMessage("Es gibt keine offene Fahrt im Fahrtenbuch mit dem Boot {boat} und LfdNr {lfdnr}.",
                d.get(BootStatus.NAME),d.get(BootStatus.LFDNR))
                 + " " + International.getString("Die Fahrt kann nicht abgebrochen werden.");
        Logger.log(Logger.ERROR,Logger.MSG_ERR_NOLOGENTRYFORBOAT,
              s + " " + International.getString("Bitte korrigiere den Status des Bootes im Admin-Modus."));
        if (interaktiv) Dialog.error(s);
      return;
    }
    Logger.log(Logger.INFO, Logger.MSG_EVT_TRIPABORT,
            International.getString("Fahrtabbruch")+": #"+d.get(BootStatus.LFDNR)+" - "+d.get(BootStatus.NAME)+" ("+d.get(BootStatus.BEMERKUNG)+")");
    Daten.fahrtenbuch.delete(d.get(BootStatus.LFDNR));
    if (!Daten.fahrtenbuch.writeFile()) {
        LogString.logError_fileWritingFailed(Daten.fahrtenbuch.getFileName(), International.getString("Fahrtenbuch"));
    }
    fahrtBeendet(boot,interaktiv);
  }


  public void fahrtNachgetragen() {
  }



  public int checkUnreadMessages() {
    boolean admin = false;
    boolean bootswart = false;

    if (Daten.nachrichten != null) {
      // durchsuche die letzten 50 Nachrichten nach ungelesenen (aus Performancegründen immer nur die letzen 50)
      for (int i=Daten.nachrichten.size()-1; i>=0 && i>Daten.nachrichten.size()-50; i--) {
        if (!Daten.nachrichten.get(i).gelesen && Daten.nachrichten.get(i).empfaenger == Nachricht.ADMIN) admin = true;
        if (!Daten.nachrichten.get(i).gelesen && Daten.nachrichten.get(i).empfaenger == Nachricht.BOOTSWART) bootswart = true;
        if (admin && bootswart) return Nachricht.ALLE;
      }
    }
    if (admin) return Nachricht.ADMIN;
    if (bootswart) return Nachricht.BOOTSWART;
    return -1;
  }


  void updateUnreadMessages() {
    try {
    switch(checkUnreadMessages()) {
      case Nachricht.ADMIN:
        adminButton.setIcon(new ImageIcon(EfaFrame.class.getResource("/de/nmichael/efa/img/mailAdmin.gif")));
        break;
      case Nachricht.BOOTSWART:
        adminButton.setIcon(new ImageIcon(EfaFrame.class.getResource("/de/nmichael/efa/img/mailBootswart.gif")));
        break;
      case Nachricht.ALLE:
        adminButton.setIcon(new ImageIcon(EfaFrame.class.getResource("/de/nmichael/efa/img/mail.gif")));
        break;
      default: adminButton.setIcon(null);
    }
    } catch(Exception e) { EfaUtil.foo(); }
    if (!Daten.efaConfig.efaDirekt_startMaximized.getValue()) packFrame("updateUnredMessages()");
  }



  void setKombiBootStatus(String boot, String lfdnr, int status, String bemerk) {
    if (bootStatus == null) return;

    String org = EfaUtil.syn2org(Daten.synBoote,boot);
    if (org == null || org.equals(boot)) return; // kein Kombiboot

    Vector syn = EfaUtil.org2syn(Daten.synBoote,org);
    if (syn == null) return; // kein Kombiboot

    for (int i=0; i<syn.size(); i++) {
      String s = (String)syn.get(i);
      if (!boot.equals(s)) {
        DatenFelder d = bootStatus.getExactComplete(s);
        if (d != null && !d.get(BootStatus.STATUS).equals(BootStatus.getStatusKey(BootStatus.STAT_HIDE))) {
          d.set(BootStatus.LFDNR,lfdnr);
          d.set(BootStatus.STATUS,BootStatus.getStatusKey(status));
          d.set(BootStatus.BEMERKUNG,bemerk);
          bootStatus.delete(s);
          bootStatus.add(d);
        }
      }
    }
  }

  public void bringFrameToFront() {
    this.toFront();
  }

  public void setBootstatusSchaden(String boot, String s) {
    if (boot == null || s == null || boot.length() == 0 || s.length() == 0) return;

    String org = EfaUtil.syn2org(Daten.synBoote,boot);
    if (org == null) org = boot;
    Vector syn = EfaUtil.org2syn(Daten.synBoote,org);
    if (syn == null) syn = new Vector();
    if (syn.size() == 0) syn.add(org);

    for (int i=0; i<syn.size(); i++) {
      String b = (String)syn.get(i);
      DatenFelder d = bootStatus.getExactComplete(b);
      if (d != null) {
        d.set(BootStatus.BOOTSSCHAEDEN,s);
        bootStatus.delete(d.get(BootStatus.NAME));
        bootStatus.add(d);
      }
    }

    bootStatus.writeFile();
  }

  String makeSureFileDoesntExist(String f) {
    int cnt = 0;
    int punkt = f.lastIndexOf(".");
    String head;
    String tail;
    if (punkt >= 0) {
      head = f.substring(0,punkt);
      tail = f.substring(punkt+1);
    } else {
      head = f;
      tail = "";
    }
    while ((new File(f)).exists()) {
      cnt++;
      f = head + "_" + cnt + "." + tail;
    }
    return f;
  }

  void autoCreateNewFb() {
    String fnameEfb = Daten.efaConfig.efaDirekt_autoNewFb_datei.getValue().trim();
    Daten.efaConfig.efaDirekt_autoNewFb_datum.unset();
    Daten.efaConfig.efaDirekt_autoNewFb_datei.setValue("");

    fnameEfb = EfaUtil.makeFullPath(EfaUtil.getPathOfFile(Daten.fahrtenbuch.getFileName()),fnameEfb);
    Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLOGBOOK,
            International.getString("Automatisches Anlegen eines neuen Fahrtenbuchs wird begonnen ..."));


    FBDaten fbDaten = null;
    Fahrtenbuch neuesFb = null;
    String oldNextFb = null;
    String oldFnameEfbb = null;
    String oldFnameEfbm = null;
    String oldFnameEfbz = null;
    String oldFnameEfbs = null;

    boolean abgebrocheneFahrten = false;

    int level = 0;
    try {
      if (!fnameEfb.toUpperCase().endsWith(".EFB")) fnameEfb = fnameEfb + ".efb";
      fnameEfb = makeSureFileDoesntExist(fnameEfb);
      String fnameBase = fnameEfb.substring(0,fnameEfb.lastIndexOf("."));
      String fnameEfbb = makeSureFileDoesntExist(fnameBase+".efbb");
      String fnameEfbm = makeSureFileDoesntExist(fnameBase+".efbm");
      String fnameEfbz = makeSureFileDoesntExist(fnameBase+".efbz");
      String fnameEfbs = makeSureFileDoesntExist(fnameBase+".efbs");
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              International.getString("Name für neue Fahrtenbuchdatei")+": "+fnameEfb);
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              International.getMessage("Name für neue {list}",
              International.getString("Bootsliste"))+": "+fnameEfbb);
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              International.getMessage("Name für neue {list}",
              International.getString("Mitgliederliste"))+": "+fnameEfbm);
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              International.getMessage("Name für neue {list}",
              International.getString("Zielliste"))+": "+fnameEfbz);
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              International.getMessage("Name für neue {list}",
              International.getString("Statistikeinstellungen"))+": "+fnameEfbs);

      oldFnameEfbb = Daten.fahrtenbuch.getDaten().boote.getFileName();
      oldFnameEfbm = Daten.fahrtenbuch.getDaten().mitglieder.getFileName();
      oldFnameEfbz = Daten.fahrtenbuch.getDaten().ziele.getFileName();
      oldFnameEfbs = Daten.fahrtenbuch.getDaten().statistik.getFileName();
      fbDaten = new FBDaten(Daten.fahrtenbuch.getDaten());
      fbDaten.boote.setFileName(fnameEfbb);
      fbDaten.mitglieder.setFileName(fnameEfbm);
      fbDaten.ziele.setFileName(fnameEfbz);
      fbDaten.statistik.setFileName(fnameEfbs);
      fbDaten.bootDatei = EfaUtil.makeRelativePath(fnameEfbb,fnameEfb);
      fbDaten.mitgliederDatei = EfaUtil.makeRelativePath(fnameEfbm,fnameEfb);
      fbDaten.zieleDatei = EfaUtil.makeRelativePath(fnameEfbz,fnameEfb);
      fbDaten.statistikDatei = EfaUtil.makeRelativePath(fnameEfbs,fnameEfb);

      // Neue Datenlisten erstellen
      level = 1;
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              "L1-START: " + International.getString("Erstelle neue Datenlisten ..."));
      if (!fbDaten.boote.writeFile()) {
          LogString.logError_fileCreationFailed(fbDaten.boote.getFileName(), International.getString("Bootsliste"));
          throw new Exception("Level 1");
      }
      if (!fbDaten.mitglieder.writeFile()) {
          LogString.logError_fileCreationFailed(fbDaten.mitglieder.getFileName(), International.getString("Mitgliederliste"));
          throw new Exception("Level 1");
      }
      if (!fbDaten.ziele.writeFile()) {
          LogString.logError_fileCreationFailed(fbDaten.ziele.getFileName(), International.getString("Zielliste"));
          throw new Exception("Level 1");
      }
      if (!fbDaten.statistik.writeFile()) {
          LogString.logError_fileCreationFailed(fbDaten.statistik.getFileName(), International.getString("Statistikeinstellungen"));
          throw new Exception("Level 1");
      }
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              "L1-DONE: " + International.getString("Fertig mit dem Erstellen der Datenlisten."));

      // Neue Fahrtenbuchdatei erstellen
      level = 2;
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              "L2-START: " + International.getString("Erstelle neues Fahrtenbuch ..."));
      neuesFb = new Fahrtenbuch(fnameEfb);
      neuesFb.setDaten(fbDaten);
      neuesFb.setPrevFb(EfaUtil.makeRelativePath(Daten.fahrtenbuch.getFileName(),neuesFb.getFileName()));
      neuesFb.setNextFb("");
      if (!neuesFb.writeFile()) {
          LogString.logError_fileCreationFailed(neuesFb.getFileName(), International.getString("Fahrtenbuch"));
          throw new Exception("Level 2");
      }
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              "L2-DONE: " + International.getString("Fertig mit dem Erstellen des Fahrtenbuchs."));

      // Fahrten für Boote, die noch unterwegs sind, abbrechen
      level = 3;
      Vector unterwegs = bootStatus.getBoote(BootStatus.STAT_UNTERWEGS);
      if (unterwegs.size()>0) {
        abgebrocheneFahrten = true;
        Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
                "L3-START: " + International.getString("Breche bestehende Fahrten ab ..."));
        if (!bootStatus.writeFile()) {
            LogString.logError_fileCreationFailed(bootStatus.getFileName(), International.getString("Bootsstatus-Liste"));
            throw new Exception("Level 3");
        }
        for (int i=0; i<unterwegs.size(); i++) {
          fahrtAbbruch((String)unterwegs.get(i),false);
        }
        level = 4;
        if (!bootStatus.writeFile()) {
            LogString.logError_fileCreationFailed(bootStatus.getFileName(), International.getString("Bootsstatus-Liste"));
            throw new Exception("Level 4");
        }
        Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
                "L4-DONE: " + International.getString("Abbrechen der Fahrten beendet."));
      }

      // Änderungen an altem Fahrtenbuch speichern
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              "L5-START: " + International.getString("Speichere Änderungen an altem Fahrtenbuch ..."));
      oldNextFb = Daten.fahrtenbuch.getNextFb(false);
      level = 5;
      Daten.fahrtenbuch.setNextFb(EfaUtil.makeRelativePath(neuesFb.getFileName(),Daten.fahrtenbuch.getFileName()));
      if (!Daten.fahrtenbuch.writeFile()) {
          LogString.logError_fileCreationFailed(Daten.fahrtenbuch.getFileName(), International.getString("Fahrtenbuch"));
          throw new Exception("Level 5");
      }
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLB_LX,
              "L5-DONE: " + International.getString("Änderungen am Fahrtenbuch gespeichert."));

      level = 6;
      Daten.fahrtenbuch = neuesFb;
      Daten.efaConfig.direkt_letzteDatei.setValue(Daten.fahrtenbuch.getFileName());
      Daten.efaConfig.writeFile();

      level = 7;
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLBDONE,
              International.getString("Automatisches Anlegen des neuen Fahrtenbuchs erfolgreich abgeschlossen."));
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTOSTARTNEWLBDONE,
              International.getMessage("Aktuelles Fahrtenbuch ist jetzt: {filename}",Daten.fahrtenbuch.getFileName()));

      Nachricht n = new Nachricht();
      n.name = Daten.EFA_SHORTNAME;
      n.empfaenger = Nachricht.ADMIN;
      n.betreff = International.getString("Neues Fahrtenbuch angelegt");
      n.nachricht = International.getString("efa hat soeben wie konfiguriert ein neues Fahrtenbuch angelegt.")+"\n"+
                    International.getMessage("Die neue Fahrtenbuchdatei ist: {filename}",Daten.fahrtenbuch.getFileName())+"\n"+
                    International.getString("Der Vorgang wurde ERFOLGREICH abgeschlossen.")+"\n\n"+
                    (abgebrocheneFahrten ? International.getString("Zum Zeitpunkt des Fahrtenbuchwechsels befanden sich noch einige Boote "+
                                           "auf dem Wasser. Diese Fahrten wurden ABGEBROCHEN. Die abgebrochenen "+
                                           "Fahrten sind in der Logdatei verzeichnet.")+"\n\n" : "") +
                    International.getString("Ein Protokoll ist in der Logdatei (Admin-Modus: Logdatei anzeigen) zu finden.");
      Daten.nachrichten.add(n);
      Daten.nachrichten.writeFile();

//      this.efaButton.requestFocus();
//      this.booteVerfuegbar.setSelectedIndex(-1);
      EfaUtil.sleep(500);
      updateBootsListen();
      EfaUtil.sleep(500);
      efaDirektBackgroundTask.interrupt();
    } catch(Exception e) {
      Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTOSTARTNEWLOGBOOK,
              International.getString("Beim Versuch, ein neues Fahrtenbuch anzulegen, trat ein Fehler auf. Alle Änderungen werden rückgängig gemacht ..."));
      switch (level) {
        case 0: break; // nothing to do
        case 7: break; // nothing to do
        case 6: break; // nothing to do
        case 5: Logger.log(Logger.WARNING, Logger.MSG_WARN_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} ...",5));
                Daten.fahrtenbuch.setNextFb(oldNextFb);
                Daten.fahrtenbuch.writeFile(); // egal, ob dies fehlschlägt oder nicht
                Logger.log(Logger.INFO, Logger.MSG_EVT_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} erfolgreich.",5));
        case 4: Logger.log(Logger.WARNING, Logger.MSG_WARN_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} ...",4));
                // nothing to do
                Logger.log(Logger.INFO, Logger.MSG_EVT_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} erfolgreich.",4));
        case 3: Logger.log(Logger.WARNING, Logger.MSG_WARN_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} ...",3));
                if (!bootStatus.readFile()) {
                  Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTONEWLOGROLLBACK,
                          International.getMessage("Rollback von Level {n} fehlgeschlagen: {msg}",
                          3,International.getString("Bootsstatus konnte nicht wiederhergestellt werden.")));
                } else {
                  Logger.log(Logger.INFO, Logger.MSG_EVT_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} erfolgreich.",3));
                }
        case 2: Logger.log(Logger.WARNING, Logger.MSG_WARN_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} ...",2));
                // nothing to do
                Logger.log(Logger.INFO, Logger.MSG_EVT_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} erfolgreich.",2));
        case 1: Logger.log(Logger.WARNING, Logger.MSG_WARN_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} ...",1));
                Daten.fahrtenbuch.getDaten().boote.setFileName(oldFnameEfbb);
                Daten.fahrtenbuch.getDaten().mitglieder.setFileName(oldFnameEfbm);
                Daten.fahrtenbuch.getDaten().ziele.setFileName(oldFnameEfbz);
                Daten.fahrtenbuch.getDaten().statistik.setFileName(oldFnameEfbs);
                int errors = 0;
                if (!Daten.fahrtenbuch.getDaten().boote.writeFile()) {
                  Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTONEWLOGROLLBACK,
                          LogString.logstring_fileCreationFailed(Daten.fahrtenbuch.getDaten().boote.getFileName(),International.getString("Bootsliste")));
                  errors++;
                }
                if (!Daten.fahrtenbuch.getDaten().mitglieder.writeFile()) {
                  Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTONEWLOGROLLBACK,
                          LogString.logstring_fileCreationFailed(Daten.fahrtenbuch.getDaten().mitglieder.getFileName(),International.getString("Mitgliederliste")));
                  errors++;
                }
                if (!Daten.fahrtenbuch.getDaten().ziele.writeFile()) {
                  Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTONEWLOGROLLBACK,
                          LogString.logstring_fileCreationFailed(Daten.fahrtenbuch.getDaten().ziele.getFileName(),International.getString("Zielliste")));
                  errors++;
                }
                if (!Daten.fahrtenbuch.getDaten().statistik.writeFile()) {
                  Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTONEWLOGROLLBACK,
                          LogString.logstring_fileCreationFailed(Daten.fahrtenbuch.getDaten().statistik.getFileName(),International.getString("Statistikeinstellungen")));
                  errors++;
                }
                if (errors == 0) {
                  Logger.log(Logger.INFO, Logger.MSG_EVT_AUTONEWLOGROLLBACK,
                        International.getMessage("Rollback von Level {n} erfolgreich.",1));
                } else {
                  Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTONEWLOGROLLBACK,
                          International.getMessage("Rollback von Level {level} mit {n} Fehlern abgeschlossen.",1,errors));
                }
                break;
        default: Logger.log(Logger.ERROR, Logger.MSG_ERR_AUTONEWLOGROLLBACK,
                International.getString("Rollback nicht möglich: efa kann den Originalzustand nicht wiederherstellen!"));
                 Logger.log(Logger.ERROR, Logger.MSG_ERR_INCONSISTENTSTATE,
                         International.getString("Kritischer Fehler")+": "+
                         International.getString("efa befindet sich in einem undefinierten Zustand! Überprüfung durch Administrator erforderlich!"));
      }
      Nachricht n = new Nachricht();
      n.name = Daten.EFA_SHORTNAME;
      n.empfaenger = Nachricht.ADMIN;
      n.betreff = International.getString("FEHLER beim Anlegen eines neuen Fahrtenbuchs");
      n.nachricht = International.getString("efa hat soeben versucht, wie konfiguriert ein neues Fahrtenbuch anzulegen.")+"\n"+
                    International.getString("Bei diesem Vorgang traten jedoch FEHLER auf.")+"\n\n"+
                    International.getString("Ein Protokoll ist in der Logdatei (Admin-Modus: Logdatei anzeigen) zu finden.");
      Daten.nachrichten.add(n);
      Daten.nachrichten.writeFile();

      Daten.efaConfig.writeFile();
      Logger.log(Logger.INFO, Logger.MSG_EVT_AUTONEWLOGROLLBACK,
              International.getString("Rückgängigmachen aller Änderungen abgeschlossen."));
    }

  }

  class EfaDirektBackgroundTask extends Thread {
    private static final int CHECK_INTERVAL = 60;
    private static final int ONCE_AN_HOUR = 60;
    EfaDirektFrame efaDirektFrame;
    int onceAnHour;
    Date date;
    Calendar cal;
    Calendar lockEfa;
    boolean framePacked;

    public EfaDirektBackgroundTask(EfaDirektFrame efaDirektFrame) {
      this.efaDirektFrame = efaDirektFrame;
      this.onceAnHour = 5; // initial nach 5 Schleifendurchläufen zum ersten Mal hier reingehen
      this.cal = new GregorianCalendar();
      this.lockEfa = null;
      this.date = new Date();
      this.framePacked = false;
    }

    private void lockEfaThread() {
      new Thread() {
        public void run() {
          efaDirektFrame.lockEfa();
        }
      }.start();
    }

    public void setEfaLockBegin(DataTypeDate datum, DataTypeTime zeit) {
      if (datum == null) {
        lockEfa = null;
      } else {
        if (zeit != null) lockEfa = new GregorianCalendar(datum.getYear(),datum.getMonth()-1,datum.getDay(),zeit.getHour(),zeit.getMinute());
        else lockEfa = new GregorianCalendar(datum.getYear(),datum.getMonth()-1,datum.getDay());
      }
    }

    private void mailWarnings() {
      try {
        BufferedReader f = new BufferedReader(new FileReader(Daten.efaLogfile));
        String s;
        Vector warnings = new Vector();
        while ( (s = f.readLine()) != null) {
          if (Logger.isWarningLine(s) && Logger.getLineTimestamp(s) > Daten.efaConfig.efaDirekt_bnrWarning_lasttime.getValue()) {
            warnings.add(s);
          }
        }
        f.close();
        if (warnings.size() == 0) {
          Logger.log(Logger.INFO, Logger.MSG_EVT_CHECKFORWARNINGS,
                  International.getMessage("Seit {date} sind keinerlei Warnungen in efa verzeichnet worden.",EfaUtil.getTimeStamp(Daten.efaConfig.efaDirekt_bnrWarning_lasttime.getValue())));
        } else {
          Logger.log(Logger.INFO, Logger.MSG_EVT_CHECKFORWARNINGS,
                  International.getMessage("Seit {date} sind {n} Warnungen in efa verzeichnet worden.",
                  EfaUtil.getTimeStamp(Daten.efaConfig.efaDirekt_bnrWarning_lasttime.getValue()),warnings.size()));
          String txt = International.getMessage("Folgende Warnungen sind seit {date} in efa verzeichnet worden:",
                  EfaUtil.getTimeStamp(Daten.efaConfig.efaDirekt_bnrWarning_lasttime.getValue()))+"\n"+
                  International.getMessage("{n} Warnungen",warnings.size())+"\n\n";
          for (int i=0; i<warnings.size(); i++) {
            txt += ((String)warnings.get(i)) + "\n";
          }
          if (Daten.nachrichten != null && Daten.efaConfig != null) {
            if (Daten.efaConfig.efaDirekt_bnrWarning_admin.getValue()) {
              Daten.nachrichten.createNachricht(Daten.EFA_SHORTNAME, Nachricht.ADMIN,International.getString("Warnungen"), txt);
            }
            if (Daten.efaConfig.efaDirekt_bnrWarning_bootswart.getValue()) {
              Daten.nachrichten.createNachricht(Daten.EFA_SHORTNAME, Nachricht.BOOTSWART,International.getString("Warnungen"), txt);
            }
          }
        }
        if (Daten.efaConfig != null) {
          Daten.efaConfig.efaDirekt_bnrWarning_lasttime.setValue(System.currentTimeMillis());
          Daten.efaConfig.writeFile();
        }

      } catch(Exception e) {
        Logger.log(Logger.ERROR, Logger.MSG_ERR_CHECKFORWARNINGS,
                International.getMessage("Benachrichtigung über WARNING's im Logfile ist fehlgeschlagen: {msg}",e.toString()));
      }
    }

    public void run() {
      // Diese Schleife läuft i.d.R. einmal pro Minute
      while(true) {

        // Reservierungs-Checker
        if (Dialog.frameCurrent() == efaDirektFrame // aktueller Frame ist EfaDirektFrame!
            && bootStatus != null) {
          boolean changes = false;
          DatenFelder d;
          for (d = bootStatus.getCompleteFirst(); d != null; d = bootStatus.getCompleteNext()) {
            // prüfen, ob für dieses Boot Reservierungen möglich sind
            if (BootStatus.getStatusID(d.get(BootStatus.STATUS)) == BootStatus.STAT_HIDE) continue;
            if (d.get(BootStatus.UNBEKANNTESBOOT).equals("+")) continue;

            // derzeit gültige Reservierungen finden
            BoatReservation reservierung = BootStatus.getReservierung(d,System.currentTimeMillis(),0);

            // verfallene Reservierungen löschen
            if (BootStatus.deleteObsoleteReservierungen(d)) {
              // Ok, alte Reservierungen wurden gelöscht: Jetzt prüfen, ob das Boot zur Zeit reserviert
              // ist. Falls ja, muß es verfügbar gemacht werden, damit ggf. neue Reservierungen zum Tragen
              // kommen können.
              if ( (BootStatus.getStatusID(d.get(BootStatus.STATUS)) == BootStatus.STAT_VERFUEGBAR ||
                    BootStatus.getStatusID(d.get(BootStatus.STATUS)) == BootStatus.STAT_NICHT_VERFUEGBAR) &&
                  d.get(BootStatus.LFDNR).equals(BootStatus.RES_LFDNR)) {
                d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_VERFUEGBAR));
                d.set(BootStatus.BEMERKUNG,BootStatus.getStatusName(BootStatus.STAT_VERFUEGBAR));
                d.set(BootStatus.LFDNR,"");
                Logger.log(Logger.INFO, Logger.MSG_EVT_RESCHECK_AVAIL,
                        "ReservationChecker: "+
                        International.getMessage("Boot {boat} auf '{status}' gesetzt: {notes}",
                                       d.get(BootStatus.NAME),BootStatus.getStatusName(BootStatus.STAT_VERFUEGBAR),
                                       International.getString("Alte Reservierungen gelöscht")));
              }
              changes = true;
            }

            if (reservierung != null) {
              // Reservierung liegt vor: Jetzt prüfen, ob das Boot zur Zeit *nicht* reserviert ist; nur
              // in diesem Fall kommt die gefundene Reservierung zum Tragen
              if (BootStatus.getStatusID(d.get(BootStatus.STATUS)) == BootStatus.STAT_VERFUEGBAR &&
                  !d.get(BootStatus.LFDNR).equals(BootStatus.RES_LFDNR)) {
                if (Daten.efaConfig.efaDirekt_resBooteNichtVerfuegbar.getValue()) {
                  d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_NICHT_VERFUEGBAR));
                }
                d.set(BootStatus.BEMERKUNG,
                        International.getMessage("reserviert für {name} ({reason}) {from_to}",
                        reservierung.getForName(),reservierung.getReason(),BootStatus.makeReservierungText(reservierung)));
                d.set(BootStatus.LFDNR,BootStatus.RES_LFDNR); // Kennzeichnung dafür, daß es sich um eine *Reservierung* handelt (und nicht Sperrung des Bootes o.ä.)
                Logger.log(Logger.INFO, Logger.MSG_EVT_RESCHECK_RESFOUND,
                        "ReservationChecker: "+
                        International.getMessage("Für Boot {boat} wurde eine Reservierung gefunden (neuer Status: '{status}')",
                                       d.get(BootStatus.NAME),BootStatus.getStatusName(BootStatus.getStatusID(d.get(BootStatus.STATUS))))+
                                       ": " + d.get(BootStatus.BEMERKUNG));
                changes = true;
              }
            } else {
              // Reservierung liegt nicht vor: Jetzt prüfen, ob das Boot zur Zeit reserviert ist; nur
              // in diesem Fall wird die aktuelle Reservierung gelöscht
              if ( (BootStatus.getStatusID(d.get(BootStatus.STATUS)) == BootStatus.STAT_VERFUEGBAR ||
                    BootStatus.getStatusID(d.get(BootStatus.STATUS)) == BootStatus.STAT_NICHT_VERFUEGBAR) &&
                  d.get(BootStatus.LFDNR).equals(BootStatus.RES_LFDNR)) {
                d.set(BootStatus.STATUS,BootStatus.getStatusKey(BootStatus.STAT_VERFUEGBAR));
                d.set(BootStatus.BEMERKUNG,BootStatus.getStatusName(BootStatus.STAT_VERFUEGBAR));
                d.set(BootStatus.LFDNR,"");
                Logger.log(Logger.INFO, Logger.MSG_EVT_RESCHECK_AVAIL,
                        "ReservationChecker: "+
                        International.getMessage("Boot {boat} auf '{status}' gesetzt: {notes}",
                        d.get(BootStatus.NAME),BootStatus.getStatusName(BootStatus.STAT_VERFUEGBAR),
                        International.getString("Reservierungszeitraum beendet.")));
                changes = true;
              }
            }
          } // end: for all boats
          if (changes) {
            if (!bootStatus.writeFile()) {
                LogString.logError_fileWritingFailed(bootStatus.getFileName(), International.getString("Bootsstatus-Liste"));
            }
            efaDirektFrame.updateBootsListen();
          }
        }

        // Nach ungelesenen Nachrichten für den Admin suchen
        updateUnreadMessages();

        // automatisches, zeitgesteuertes Beenden von efa ?
        if (Daten.efaConfig.efaDirekt_exitTime.isSet()
            && System.currentTimeMillis() > Daten.efaStartTime + (Daten.AUTO_EXIT_MIN_RUNTIME+1)*60*1000
            ) {
          date.setTime(System.currentTimeMillis());
          cal.setTime(date);
          int now = cal.get(Calendar.HOUR_OF_DAY)*60 + cal.get(Calendar.MINUTE);
          int exitTime = Daten.efaConfig.efaDirekt_exitTime.getValueHour()*60 + Daten.efaConfig.efaDirekt_exitTime.getValueMinute();
          if ( (now >= exitTime && now < exitTime+Daten.AUTO_EXIT_MIN_RUNTIME) || (now+(24*60) >= exitTime && now+(24*60) < exitTime+Daten.AUTO_EXIT_MIN_RUNTIME) ) {
            Logger.log(Logger.INFO, Logger.MSG_EVT_TIMEBASEDEXIT,
                    International.getString("Eingestellte Uhrzeit zum Beenden von efa erreicht!"));
            if (System.currentTimeMillis() - efaDirektFrame.lastUserInteraction < Daten.AUTO_EXIT_MIN_LAST_USED*60*1000) {
              Logger.log(Logger.INFO, Logger.MSG_EVT_TIMEBASEDEXITDELAY,
                      International.getMessage("Beenden von efa wird verzögert, da efa innerhalb der letzten {n} Minuten noch benutzt wurde ...",
                      Daten.AUTO_EXIT_MIN_LAST_USED));
            } else {
              EfaExitFrame.exitEfa(International.getString("Zeitgesteuertes Beenden von efa"),false,EFA_EXIT_REASON_TIME);
            }
          }
        }

        // automatisches Beenden nach Inaktivität ?
        if (Daten.efaConfig.efaDirekt_exitIdleTime.isSet() && Daten.efaConfig.efaDirekt_exitIdleTime.getValue() > 0
            && System.currentTimeMillis() - efaDirektFrame.lastUserInteraction > Daten.efaConfig.efaDirekt_exitIdleTime.getValue()*60*1000
            ) {
            Logger.log(Logger.INFO, Logger.MSG_EVT_INACTIVITYBASEDEXIT,
                    International.getString("Eingestellte Inaktivitätsdauer zum Beenden von efa erreicht!"));
            EfaExitFrame.exitEfa(International.getString("Zeitgesteuertes Beenden von efa"),false,EFA_EXIT_REASON_TIME);
        }

        // automatischer, zeitgesteuerter Neustart von efa ?
        if (Daten.efaConfig.efaDirekt_restartTime.isSet()
            && System.currentTimeMillis() > Daten.efaStartTime + (Daten.AUTO_EXIT_MIN_RUNTIME +1)*60*1000
            ) {
          date.setTime(System.currentTimeMillis());
          cal.setTime(date);
          int now = cal.get(Calendar.HOUR_OF_DAY)*60 + cal.get(Calendar.MINUTE);
          int restartTime = Daten.efaConfig.efaDirekt_restartTime.getValueHour()*60 + Daten.efaConfig.efaDirekt_restartTime.getValueMinute();
          if ( (now >= restartTime && now < restartTime+Daten.AUTO_EXIT_MIN_RUNTIME) || (now+(24*60) >= restartTime && now+(24*60) < restartTime+Daten.AUTO_EXIT_MIN_RUNTIME) ) {
            Logger.log(Logger.INFO,"Automatischer Neustart von efa (einmal täglich).");
            if (System.currentTimeMillis() - efaDirektFrame.lastUserInteraction < Daten.AUTO_EXIT_MIN_LAST_USED*60*1000) {
              Logger.log(Logger.INFO,"Neustart von efa wird verzögert, da efa innerhalb der letzten "+Daten.AUTO_EXIT_MIN_LAST_USED+" Minuten noch benutzt wurde ...");
            } else {
              EfaExitFrame.exitEfa("Automatischer Neustart von efa",true,EFA_EXIT_REASON_AUTORESTART);
            }
          }
        }

        // efa zeitgesteuert sperren
        if (lockEfa != null) {
          date.setTime(System.currentTimeMillis());
          cal.setTime(date);
          if (cal.after(lockEfa)) {
            lockEfaThread();
            lockEfa = null;
          }
        }

        // automatisches Beginnen eines neuen Fahrtenbuchs (z.B. zum Jahreswechsel)
        if (Daten.applMode == Daten.APPL_MODE_NORMAL &&
            Daten.efaConfig.efaDirekt_autoNewFb_datum.isSet() &&
            Daten.efaConfig.efaDirekt_autoNewFb_datei.getValue().length() > 0) {
          if (EfaUtil.secondDateIsEqualOrAfterFirst(Daten.efaConfig.efaDirekt_autoNewFb_datum.toString(),EfaUtil.getCurrentTimeStampDD_MM_YYYY())) {
            efaDirektFrame.autoCreateNewFb();
          }
        }

        // immer im Vordergrund
        if (Daten.efaConfig.efaDirekt_immerImVordergrund.getValue() && this.efaDirektFrame != null &&
            Dialog.frameCurrent() == this.efaDirektFrame) {
          Window[] windows = this.efaDirektFrame.getOwnedWindows();
          boolean topWindow = true;
          if (windows != null) {
            for (int i=0; i<windows.length; i++) {
              if (windows[i] != null && windows[i].isVisible()) topWindow = false;
            }
          }
          if (topWindow && Daten.efaConfig.efaDirekt_immerImVordergrundBringToFront.getValue()) {
            this.efaDirektFrame.bringFrameToFront();
          }
        }

        // Fokus-Kontrolle
        if (this.efaDirektFrame != null && this.efaDirektFrame.getFocusOwner() == this.efaDirektFrame) {
          // das Frame selbst hat den Fokus: Das soll nicht sein! Gib einer Liste den Fokus!
          if (this.efaDirektFrame.booteVerfuegbar != null && this.efaDirektFrame.booteVerfuegbar.getSelectedIndex()>=0) this.efaDirektFrame.booteVerfuegbar.requestFocus();
          else if (this.efaDirektFrame.booteAufFahrt != null && this.efaDirektFrame.booteAufFahrt.getSelectedIndex()>=0) this.efaDirektFrame.booteAufFahrt.requestFocus();
          else if (this.efaDirektFrame.booteNichtVerfuegbar != null && this.efaDirektFrame.booteNichtVerfuegbar.getSelectedIndex()>=0) this.efaDirektFrame.booteNichtVerfuegbar.requestFocus();
          else if (this.efaDirektFrame.booteVerfuegbar != null) this.efaDirektFrame.booteVerfuegbar.requestFocus();
        }

        // Aktivitäten einmal pro Stunde
        if (--onceAnHour <= 0) {
          System.gc(); // Damit Speicherüberwachung funktioniert (anderenfalls wird CollectionUsage nicht aktualisiert; Java-Bug)
          onceAnHour = ONCE_AN_HOUR;
          if (Logger.isTraceOn(Logger.TT_BACKGROUND)) {
              Logger.log(Logger.DEBUG, Logger.MSG_DEBUG_EFABACKGROUNDTASK,
                      "EfaDirektBackgroundTask: alive!");
          }

          // WARNINGs aus Logfile an Admins verschicken
          if (System.currentTimeMillis() >= Daten.efaConfig.efaDirekt_bnrWarning_lasttime.getValue() + 7l*24l*60l*60l*1000l &&
              (Daten.efaConfig.efaDirekt_bnrWarning_admin.getValue() || Daten.efaConfig.efaDirekt_bnrWarning_bootswart.getValue()) && Daten.efaLogfile != null) {
            mailWarnings();
          }
        }

        // Speicher-Überwachung
        try {
//          System.gc(); // !!! ONLY ENABLE FOR DEBUGGING PURPOSES !!!
          if (de.nmichael.efa.java15.Java15.isMemoryLow(Daten.MIN_FREEMEM_PERCENTAGE,Daten.WARN_FREEMEM_PERCENTAGE)) {
            efaDirektFrame.exitOnLowMemory("EfaDirektBackgroundTask: MemoryLow",false);
          }
        } catch(UnsupportedClassVersionError e) {
          EfaUtil.foo();
        } catch(NoClassDefFoundError e) {
          EfaUtil.foo();
        }

        try {
          Thread.sleep(CHECK_INTERVAL * 1000);
        } catch(Exception e) {
          // wenn unterbrochen, dann versuch nochmal, 2 Sekunden zu schlafen, und arbeite dann weiter!! ;-)
          try {
            Thread.sleep(2 * 1000);
          } catch(Exception ee) { EfaUtil.foo(); }

          // Bugfix, da efa unter manchen Versionen beim Start nicht richtig gepackt wird.
          if (!framePacked) {
            if (/*Daten.javaVersion.startsWith("1.3")  && */ efaDirektFrame != null) {
              if (Daten.efaConfig != null) {
                if (!Daten.efaConfig.efaDirekt_startMaximized.getValue()) efaDirektFrame.packFrame("EfaDirektBackgroundTask");
                else {
                  if (efaDirektFrame.jScrollPane1 != null && efaDirektFrame.westPanel != null && efaDirektFrame.contentPane != null) {
                    efaDirektFrame.jScrollPane1.setSize(efaDirektFrame.jScrollPane1.getPreferredSize());
                    efaDirektFrame.westPanel.validate();
                    efaDirektFrame.contentPane.validate();
                  }
                }
              }
            }
            if (efaDirektFrame != null && efaDirektFrame.efaFrame != null) {
              efaDirektFrame.efaFrame.packFrame("EfaDirektBackgroundTask.run()");
            }
            framePacked = true; // nicht nochmal machen, sondern nur einmal beim Start
          }

        }
      } // end: while(true)
    } // end: run
  }

}
